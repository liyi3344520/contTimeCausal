{
    "contents" : "#' Continuous-time Structural Failure Time Model (ctSFTM)\n#'\n#' The function estimates the effect of treatment effect for a survival outcome under a SFTM\n#' with time-varying treatment and confounding in the presence of dependent censoring.\n#'\n#' @param V the time to treatment discontinuation or failure or censoring (n x 1)\n#' @param deltaV the binary indicator of treatment discontinuation at time V (n x 1)\n#' @param U the time to failure or censoring (n x 1)\n#' @param deltaD the binary indicator of failure at time U (n x 1)\n#' @param Lti 1-dimensional baseline covariate (n x 1)\n#' @param Ltd4Vtime a matrix  consisting of the time-dependent covariate (n x ltimeV)\n#'\n#' ltimeV is the length of uniquely observed treatment discontinuation times (called V times)\n#'\n#' one row represents one individual's time-dependent covariates\n#'\n#' columns represent ordered V times\n#' @param Ltd4Utime a matrix  consisting of the time-dependent covariate (n x ltimeU)\n#'\n#' ltimeU is the length of uniquely observed failure times (called U times)\n#'\n#' one row represents one individual's time-dependent covariates\n#'\n#' columns represent ordered U times\n#'\n#' @return\n#'\n#' \\code{est}: estimate of the SFTM parameter\n#'\n#'\n#' @import survival MASS zoo\n#'\n#' @details\n#' The SFTM assumes that the potential failure time \\code{U} had the individual never received treatment and the observed failure time \\code{T} follow\n#'\\deqn{U ~ \\int_0^T e^{\\psi A_u}d u, }\n#'where \\code{~} means \"has the same distribution as\", and \\eqn{A_u} is the treatment indicator at time \\eqn{u}.\n#'We assume that the individual continuously received treatment until time \\eqn{V}.\n#' The observed failure time can be censored assuming the censoring time is independent of the failure time given the treatment and covariate history (the so-called ignorable censoring).\n#'The current function provides a template to handle one-dimensional baseline covariate and one-dimensional time-dependent covariate;\n#'extension to handling multiple baseline  and  time-dependent covariates is possible.\n#'Variance estimate should be implemented by delete-one-group jackknifing and recalling ctSFTM.\n#'\n#' @seealso \\code{\\link{ctCoxMSM}}\n#'\n#'@references Yang, S., K. Pieper, and F. Cools. (2019) Semiparametric estimation of structural failure time model in continuous-time processes.\n#'   \\url{https://arxiv.org/abs/1808.06408}\n#'\n#' @examples\n#'\n#' library(\"survival\")\n#' library(\"MASS\")\n#' library(\"zoo\")\n#'\n#'  set.seed(seed=11)\n#'  n=1000\n#'\n#'  ## generate time-indept covariate\n#'\n#'  Lti<-rbinom(n,1,0.55)\n#'  Lti<-Lti-mean(Lti)\n#'\n#'  ## generate time-dept covariate\n#'\n#'  Sigma<-matrix(0,3,3)\n#'  for(i in 1:3){\n#'    for(j in 1:3){\n#'      Sigma[i,j]<-0.7^(abs(i-j))\n#'    }\n#'  }\n#'\n#'  ## Vtd represents the values of covariate at times t1=0, t2=5, and t3=10.\n#'  ## We assume that the time-dependent variable remains constant between measurements.\n#'\n#'  Vtdtemp<-mvrnorm(n = n, rep(0,3), Sigma)\n#'  Vtd<-Vtdtemp\n#'  t<-c(0,5,10,100)\n#'  colnames(Vtd)<-paste(\"t\",1:3,sep=\"\")\n#'\n#'  ## generate time-to-events\n#'  ## D =time to death if never stop treatment (time-indep Cox)\n#'  ## V =time to discontinuity (time-dep Cox)\n#'  ## avoiding the same time points for V and U\n#'\n#'  ## generate D according to an exp distribution\n#'\n#'  D<-rexp(n=n,0.2)\n#'\n#'  Vtd<-Vtdtemp+ matrix((D-20)/5,n,3,byrow=FALSE)\n#'  colnames(Vtd)<-paste(\"t\",1:3,sep=\"\")\n#'\n#'  ## generate V according to a tme-dept Cox using Bender et al (2005)\n#'\n#'  lambdaV <- 0.15;  betaV <- c(0.15,0.15)\n#'\n#'  v  <- runif(n=n)\n#'  temp1 <- (- log(1-v) / (lambdaV * exp(cbind(Lti,Vtd[,1]) %*% betaV)))\n#'  v  <- runif(n=n)\n#'  temp2 <- (- log(1-v) / (lambdaV * exp(cbind(Lti,Vtd[,2]) %*% betaV)))\n#'  v  <- runif(n=n)\n#'  temp3 <- (- log(1-v) / (lambdaV * exp(cbind(Lti,Vtd[,3]) %*% betaV)))\n#'  id1<-(temp1 < t[2])\n#'  id2<-(temp2 < (t[3]-t[2]))\n#'  id3<-(temp3 < (t[4]-t[3]))\n#'  V2<- id1*temp1 + (1-id1)*id2*(temp2+t[2]) + (1-id1)*(1-id2)*(temp3+t[3])\n#'\n#'  ## generate Tv according to a SFTM\n#'  psi<- 0\n#'  true<-exp(psi)\n#'\n#'  id1<-D<=V2\n#'  T.temp11<-D*exp(-psi[1])\n#'\n#'  id11<-T.temp11<=V2\n#'  id12<-T.temp11>V2\n#'  T.temp12<-D + V2-exp(psi[1])*V2\n#'\n#'  id2<-D>V2\n#'  T.temp2<-D + V2-exp(psi[1])*V2\n#'\n#'  Tv<-id11*T.temp11+id12*T.temp12\n#'\n#'  ## generate censoring according to time-dept Cox\n#'  ## nu=time to censoring\n#'\n#'  lambdaC <- 0.025; betaC <- c(0.15,0.15)\n#'\n#'  v  <- runif(n=n)\n#'  temp3 <- (- log(1-v) / (lambdaC * exp(cbind(Lti,1) %*% betaC)))\n#'  v  <- runif(n=n)\n#'  temp4 <- (- log(1-v) / (lambdaC * exp(cbind(Lti,0) %*% betaC)))\n#'  id3<-(temp3 < V2)\n#'  nu<- id3*temp3 + (1-id3)*(V2+temp4)\n#'\n#'  check1<-sort( c(V2, apply(cbind(Tv,nu),1,min)))\n#'  check2<-c(check1,9999)-c(0,check1)\n#'\n#'  if(min(check2)<10^-6){\n#'    print(\"Please re-generate the data in order to avoid the same time points for V and U\")\n#'  }\n#'\n#'  U<-apply( cbind(Tv,nu) ,1,min)\n#'  deltaD <- ( U<nu )\n#'  deltaV<-(V2<U)&(V2<nu)\n#'  V<-apply(cbind(V2,U,nu),1,min)\n#'\n#'  ## time-dependent covariate\n#'  ## Ltd4Vtime is a n x ltimeV matrix consisting of the time-dependent cov\n#'  ## each row represents each indiviudal\n#'  ## columns represent ordered V times (the realized treatment discontinuation times)\n#'\n#'  data1<-list(time=V,status=deltaV)\n#'  fit<-coxph(Surv(time, status) ~ . , data1)\n#'  ss<-survfit(fit)\n#'  obsV.times<-ss$time\n#'  ltime<-length(obsV.times)\n#'\n#'  id1<- (obsV.times < t[2])\n#'  id2<-((obsV.times < t[3])&(obsV.times > t[2]))\n#'  id3<- (obsV.times > t[3])\n#'  Ltd4Vtime<-matrix(NA,nrow=n,ncol=ltime)\n#'  Ltd4Vtime[,which(id1==1)]<-Vtd[,1]\n#'  Ltd4Vtime[,which(id2==1)]<-Vtd[,2]\n#'  Ltd4Vtime[,which(id3==1)]<-Vtd[,3]\n#'\n#'  ## Ltd4Utime is a n x ltimeU matrix consisting of the time-dependent cov\n#'  ## each row represents each indiviudal\n#'  ## columns represent ordered U times (the realized event times)\n#'\n#'  data2<-list(time=U,status=1-deltaD)\n#'  fit<-coxph(Surv(time, status) ~ . , data2)\n#'  ss<-survfit(fit)\n#'  obsU.times<-ss$time[ss$n.event==1]\n#'  ltimeU<-length(obsU.times)\n#'  id1<- (obsU.times < t[2])\n#'  id2<-((obsU.times < t[3])&(obsU.times > t[2]))\n#'  id3<- (obsU.times > t[3])\n#'  Ltd4Utime<-matrix(NA,nrow=n,ncol=ltimeU)\n#'  Ltd4Utime[,which(id1==1)]<-Vtd[,1]\n#'  Ltd4Utime[,which(id2==1)]<-Vtd[,2]\n#'  Ltd4Utime[,which(id3==1)]<-Vtd[,3]\n#'\n#'  true\n#'  ctSFTM(V,deltaV,U,deltaD,Lti,Ltd4Vtime,Ltd4Utime)$est\n#'\n#'\n#' @export\n#'\n\nctSFTM<-function(V,deltaV,U,deltaD,Lti,Ltd4Vtime,Ltd4Utime){\n\n  ## Fit a time-dependent Cox proportional hazards model for V:\n  ## The baseline hazard function estimated by \"survfit.coxph\"\n  ## is the hazard when all covariates are equal to their sample means.\n  ## In order to evaluate the hazard function correctly, we first\n  ## need to centerize the covariates by subtracting their means.\n\n  ## This step does not not fit a time-dependent Cox PH model yet\n  ## this step only prepares obsV.times for later use\n\n  n<-length(V)\n  data1<-list(time=V,status=deltaV)\n  fit<-coxph(Surv(time, status) ~ . , data1)\n  ss<-survfit(fit)\n  obsV.times<-ss$time\n  ltime<-length(obsV.times)\n  cumu1.hazard<- -log(ss$surv)\n  hazard.KM<-cumu1.hazard-c(0,cumu1.hazard[1:(length(cumu1.hazard)-1)])\n  ss.KM<-ss$surv\n\n  ## This step fits a time-dependent Cox PH model\n  ## creat time-dependent covariate\n\n  cnames<-c(\"patnum\",\"start\",\"stop\",\"deltaD\",\"deltaV\",\"V\",\"D.time\",\"V.time\",\"Lti\",\"Vtd\")\n  dataforTDcoxPH<-matrix(0,(ltime)*n,length(cnames))\n  colnames(dataforTDcoxPH)<-cnames\n  dataforTDcoxPH[,\"start\"]   <-c(0,obsV.times[1:(ltime-1)])\n  dataforTDcoxPH[,\"stop\"]    <-obsV.times[1:(ltime)]\n  dataforTDcoxPH[,\"patnum\"]  <-rep(1:n   ,each=(ltime))\n  dataforTDcoxPH[,\"V\"]       <-rep(V ,each=(ltime))\n  dataforTDcoxPH[,\"deltaD\"] <-rep(deltaD,each=(ltime))\n  dataforTDcoxPH[,\"deltaV\"] <-rep(deltaV,each=(ltime))\n  dataforTDcoxPH[,\"Lti\"]     <-rep(Lti   ,each=(ltime))\n  dataforTDcoxPH[,\"D.time\"]  <-(dataforTDcoxPH[,\"V\"]>dataforTDcoxPH[,\"start\"])*\n    (dataforTDcoxPH[,\"V\"]<=dataforTDcoxPH[,\"stop\"])*\n    (dataforTDcoxPH[,\"deltaD\"]==1)\n  dataforTDcoxPH[,\"V.time\"]  <-(dataforTDcoxPH[,\"V\"]>dataforTDcoxPH[,\"start\"])*\n    (dataforTDcoxPH[,\"V\"]<=dataforTDcoxPH[,\"stop\"])*\n    (dataforTDcoxPH[,\"deltaV\"]==1)\n  dataforTDcoxPH[,\"Vtd\"]<-as.vector(t(Ltd4Vtime))\n  retain<-which( (dataforTDcoxPH[,\"V\"]>dataforTDcoxPH[,\"start\"]) )\n  dataforTDcoxPH<-dataforTDcoxPH[retain,]\n  dataforTDcoxPH.list<-list(start=dataforTDcoxPH[,\"start\"],\n                            stop=dataforTDcoxPH[,\"stop\"],\n                            V.time=dataforTDcoxPH[,\"V.time\"],\n                            Lti=dataforTDcoxPH[,\"Lti\"]-mean(dataforTDcoxPH[,\"Lti\"]),\n                            Vtd=dataforTDcoxPH[,\"Vtd\"]-mean(dataforTDcoxPH[,\"Vtd\"]))\n  Lti4Ltime<-Lti\n  Lti4Ltime<-Lti4Ltime-mean(dataforTDcoxPH[,\"Lti\"])\n  Ltd4Vtime<-Ltd4Vtime-mean(dataforTDcoxPH[,\"Vtd\"])\n\n  fit<- coxph(Surv(start, stop, V.time) ~Lti+Vtd,data=dataforTDcoxPH.list)\n  gammahat1<-fit$coefficients\n  fit$coefficient\n  ss<-survfit(fit)\n  cumu1.hazard<- -log(ss$surv)\n  base.hazard1<-cumu1.hazard-c(0,cumu1.hazard[1:(length(cumu1.hazard)-1)])\n  hazard1<-base.hazard1\n  obsV.times<-ss$time\n  ltime<-length(obsV.times)\n\n  ## overall survival function for U using KM estimator\n\n  data4<-list(time=U,status=deltaD)\n  fit<-coxph(Surv(time, status) ~ . , data4)\n  ss<-survfit(fit)\n  obs2.times<-ss$time[ss$n.event==1]\n  ltime2<-length(obs2.times)\n\n  ############################################\n  # create dMv\n  # for each pat at each v time\n  ############################################\n\n  hazard2<-piTtilde<-matrix(hazard1,nrow=n,ncol=ltime,byrow=TRUE)*\n    exp(Lti4Ltime*gammahat1[1]+Ltd4Vtime*gammahat1[2])\n  hazard2[hazard2>1]<-1\n  temp1<-1-piTtilde\n  temp1[temp1<0]<-1\n  Kt<-t(apply(temp1,1,cumprod))\n  c4<-exp(-(Lti4Ltime*gammahat1[1]+Ltd4Vtime*gammahat1[2]))\n\n  dM1u <- piTtilde\n  matobs.times<-matrix(obsV.times,nrow=n,ncol=ltime,byrow=TRUE)\n  A.mat<- matobs.times<=matrix(V,nrow=n,ncol=ltime,byrow=FALSE)\n  V.mat<-matrix(V,nrow=n,ncol=ltime,byrow=FALSE)\n  U.mat<-matrix(U,nrow=n,ncol=ltime,byrow=FALSE)\n  dNu<-(V.mat==matobs.times)*(matrix(deltaV,nrow=n,ncol=ltime,byrow=FALSE))\n  iXs1 <- (matobs.times < V.mat)|(matobs.times == V.mat) # ontrt time points indicator\n  iXs2 <- (matobs.times < U.mat)|(matobs.times == U.mat) # survival time points indicator\n  dMu<- ( dNu-dM1u *iXs1*iXs2)\n\n  #############################################################\n  ## Calculate IPCW\n  ## using S data first\n  ## then smoothing the weights for the U data\n  ##\n  ## exp(-integrated hazard) is approx by prod of (1-hazard);\n  #############################################################\n\n  data4<-list(time=U,status=1-deltaD)\n  fit<-coxph(Surv(time, status) ~ . , data4)\n  ss<-survfit(fit)\n  cumu3.hazard<- -log(ss$surv)\n  K3t.KM<- ss$surv[ss$n.event==1]\n  obsU.times<-ss$time[ss$n.event==1]\n  ltimeU<-length(obsU.times)\n\n  cnames<-c(\"patnum\",\"start\",\"stop\",\"deltaD\",\"U\",\"V\",\"S.time\",\"Z\",\"Lti\",\"Vtd\")\n  dataforTScoxPH<-matrix(0,(ltimeU)*n,length(cnames))\n  colnames(dataforTScoxPH)<-cnames\n  dataforTScoxPH[,\"start\"]   <-c(0,obsU.times[1:(ltimeU-1)])\n  dataforTScoxPH[,\"stop\"]    <-obsU.times[1:(ltimeU)]\n  dataforTScoxPH[,\"patnum\"]  <-rep(1:n   ,each=(ltimeU))\n  dataforTScoxPH[,\"U\"]       <-rep(U ,each=(ltimeU))\n  dataforTScoxPH[,\"V\"]       <-rep(V*deltaV+(V+1)*(1-deltaV) ,each=(ltimeU))\n  dataforTScoxPH[,\"Z\"]       <-dataforTScoxPH[,\"V\"]>dataforTScoxPH[,\"stop\"]\n  dataforTScoxPH[,\"deltaD\"] <-rep(deltaD,each=(ltimeU))\n  dataforTScoxPH[,\"Lti\"]     <-rep(Lti   ,each=(ltimeU))\n  dataforTScoxPH[,\"S.time\"]<-(dataforTScoxPH[,\"U\"]>dataforTScoxPH[,\"start\"])*\n    (dataforTScoxPH[,\"U\"]<=dataforTScoxPH[,\"stop\"])*\n    (dataforTScoxPH[,\"deltaD\"]==0)\n  dataforTScoxPH[,\"Vtd\"]<-as.vector(t(Ltd4Utime))\n  retain<-which( (dataforTScoxPH[,\"U\"]>dataforTScoxPH[,\"start\"]) )\n  dataforTScoxPH<-dataforTScoxPH[retain,]\n  dataforTScoxPH.list<-list(start=dataforTScoxPH[,\"start\"],\n                            stop=dataforTScoxPH[,\"stop\"],\n                            S.time=dataforTScoxPH[,\"S.time\"],\n                            Lti=dataforTScoxPH[,\"Lti\"]-mean(dataforTScoxPH[,\"Lti\"]),\n                            Vtd=dataforTScoxPH[,\"Vtd\"]-mean(dataforTScoxPH[,\"Vtd\"]),\n                            Z=dataforTScoxPH[,\"Z\"])\n  Lti4Utime<-Lti\n  Lti4Utime<-Lti4Utime-mean(dataforTScoxPH[,\"Lti\"])\n  Ltd4Utime<-Ltd4Utime-mean(dataforTScoxPH[,\"Vtd\"])\n\n  fit<- coxph(Surv(start, stop, S.time) ~Lti+Z,\n              data=dataforTScoxPH.list)\n  gammahat3<-fit$coefficients\n\n  ss<-survfit(fit)\n  cumu3.hazard<- -log(ss$surv)\n  base.hazard3<-cumu3.hazard-c(0,cumu3.hazard[1:(length(cumu3.hazard)-1)])\n  hazard3<-base.hazard3\n  if((length(hazard3)-ltimeU)>0){\n    hazard3<-c(0,base.hazard3)\n  }\n\n  matobsU.times<-matrix(obsU.times,nrow=n,ncol=ltimeU,byrow=TRUE)\n  Z<- matobsU.times<=matrix(V,nrow=n,ncol=ltimeU,byrow=FALSE)\n  V.mat<-matrix(V,nrow=n,ncol=ltimeU,byrow=FALSE)\n\n  obs32.times<-c(obsU.times,obs2.times)\n  jjorder<-sort(obs32.times,index.return = TRUE)\n  obs.times<-jjorder$x\n  obs.timesid<-jjorder$ix\n  augN<-length(obs.times)\n\n  hazard3<-matrix(hazard3,nrow=n,ncol=ltimeU,byrow=TRUE)*\n    exp(Lti4Utime*gammahat3[1]+Z*gammahat3[2])\n  piTtilde<-hazard3\n\n  dLambda3c <- hazard3\n  U3.mat<-matrix(U,nrow=n,ncol=ltimeU,byrow=FALSE)\n  dN3c<-(U3.mat==matobsU.times)*(matrix(1-deltaD,nrow=n,ncol=ltimeU,byrow=FALSE))\n  iXs3 <- (matobsU.times < U3.mat)|(matobsU.times == U3.mat)\n  dM3c<- ( dN3c-dLambda3c *iXs3)\n\n  temp1<-1-piTtilde\n  temp1[temp1<=0]<-1\n  K3t<-t(apply(temp1,1,cumprod))#*id_piTtilde # now can be zero\n  K3t.forD<-K3t.forD.KM<-matrix(NA,n,augN)\n  K3t.forD[,which((jjorder$ix<(ltimeU+1)))]<-K3t\n  K3t.forD.KM[,which((jjorder$ix<(ltimeU+1)))]<-K3t.KM\n\n  eg1 <- cbind(1:augN,t(K3t.forD))\n  egz1 <- zoo(eg1)\n  index(egz1) <- egz1[,1]\n  temp1 <- na.approx(egz1, rule = 2)\n  temp1 <- temp1[,-1]\n  temp1 <- as.matrix(temp1)\n  K3t.forD<-t(temp1)\n  K3t<-K3t.forD[,which((jjorder$ix>(ltimeU)))]\n\n  eg1 <- cbind(1:augN,t(K3t.forD.KM))\n  egz1 <- zoo(eg1)\n  index(egz1) <- egz1[,1]\n  temp1 <- na.approx(egz1, rule = 2)\n  temp1 <- temp1[,-1]\n  temp1 <- as.matrix(temp1)\n  K3t.forD.KM<-t(temp1)\n  K3t.KM<-K3t.forD.KM[,which((jjorder$ix>(ltimeU)))]\n  K3s<-K3t.forD[,which((jjorder$ix<=(ltimeU)))]\n\n  matobs2.times<-matrix(obs2.times,nrow=n,ncol=ltime2,byrow=TRUE)\n  matK3t<-K3t\n  matK3t.KM<-K3t.KM\n\n  U2.mat<-matrix(U,nrow=n,ncol=ltime2,byrow=FALSE) # U time mat 2\n  Delta2.mat<-matrix(deltaD,nrow=n,ncol=ltime2,byrow=FALSE) # U time mat 2\n  K3   <-apply( (U2.mat==matobs2.times)*Delta2.mat*matK3t,1,sum)\n  K3.KM<-apply( (U2.mat==matobs2.times)*Delta2.mat*matK3t.KM,1,sum)\n  IPCW<-rep(0,n)\n  IPCW[deltaD>0]<-1/K3[deltaD>0]\n\n  part1<-U*(1-deltaV)+V*(deltaV)\n  part2<-(U-V)*(deltaV)\n\n  lm.out<-lm(part1[IPCW>0]~Lti[IPCW>0]+Vtd[IPCW>0,1],weights=IPCW[IPCW>0])\n  coeff<-lm.out$coefficients\n  Epart1<-coeff[1]+coeff[2]*Lti+coeff[3]*Vtd[,1]\n\n  lm.out<-lm(part2[IPCW>0]~Lti[IPCW>0]+Vtd[IPCW>0,1],weights=IPCW[IPCW>0])\n  coeff<-lm.out$coefficients\n  Epart2<-coeff[1]+coeff[2]*Lti+coeff[3]*Vtd[,1]\n\n  x0psi.mat1<-matrix(part1,nrow=n,ncol=ltime,byrow=FALSE)\n  x0psi.mat2<-matrix(part2,nrow=n,ncol=ltime,byrow=FALSE)\n  x0psi.mat1c<-matrix(part1-Epart1,nrow=n,ncol=ltime,byrow=FALSE)\n  x0psi.mat2c<-matrix(part2-Epart2,nrow=n,ncol=ltime,byrow=FALSE)\n\n  sum41c<-sum(c4*x0psi.mat1c*dMu*iXs1*iXs2*IPCW)\n  sum42c<-sum(c4*x0psi.mat2c*dMu*iXs1*iXs2*IPCW)\n  est<- -sum42c/sum41c\n\n  est\n\n  return(list(est=est))\n}\n",
    "created" : 1550263589554.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1380516505",
    "id" : "46FBCA03",
    "lastKnownWriteTime" : 1550258054,
    "path" : "~/contTimeCausal/R/ctSFTM.R",
    "project_path" : "R/ctSFTM.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}